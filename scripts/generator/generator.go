package main

import (
	"flag"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

var tTmpl = `// Code generated by generator. DO NOT EDIT.

package {{.Name}}

import "testing"

func nonTestHelper({{.Name}} int) {}

func helperWithoutHelper({{.Name}} *testing.{{.UName}}) {} {{if or (eq .Check "") (eq .Check "begin")}}// want "test helper function should start from {{.Name}}.Helper()"{{end}}

func helperWithHelper({{.Name}} *testing.{{.UName}}) {
	{{.Name}}.Helper()
}

func helperWithEmptyStringBeforeHelper({{.Name}} *testing.{{.UName}}) {

	{{.Name}}.Helper()
}

func helperWithHelperAfterAssignment({{.Name}} *testing.{{.UName}}) { {{if or (eq .Check "") (eq .Check "begin")}}// want "test helper function should start from {{.Name}}.Helper()"{{end}}
	_ = 0
	{{.Name}}.Helper()
}

func helperWithHelperAfterOtherCall({{.Name}} *testing.{{.UName}}) { {{if or (eq .Check "") (eq .Check "begin")}}// want "test helper function should start from {{.Name}}.Helper()"{{end}}
	f()
	{{.Name}}.Helper()
}

func helperWithHelperAfterOtherSelectionCall({{.Name}} *testing.{{.UName}}) { {{if or (eq .Check "") (eq .Check "begin")}}// want "test helper function should start from {{.Name}}.Helper()"{{end}}
	{{.Name}}.Fail()
	{{.Name}}.Helper()
}

func helperWithNotFirst(s string, {{.Name}} *testing.{{.UName}}, i int) { {{if or (eq .Check "") (eq .Check "first")}}// want "parameter \\*testing.{{.UName}} should be the first"{{end}}
	{{.Name}}.Helper()
}

func helperWithIncorrectName(o *testing.{{.UName}}) { {{if or (eq .Check "") (eq .Check "name")}}// want "parameter \\*testing.{{.UName}} should have name {{.Name}}"{{end}}
	o.Helper()
}

func helperWithAnonymousHelper({{.Name}} *testing.{{.UName}}) {
	{{.Name}}.Helper()
	func({{.Name}} *testing.{{.UName}}) {}({{.Name}}) {{if or (eq .Check "") (eq .Check "begin")}}// want "test helper function should start from {{.Name}}.Helper()"{{end}}
}

func f() {}
`

func main() {
	var name, path, check string

	flag.StringVar(&name, "name", "", "")
	flag.StringVar(&path, "path", "", "")
	flag.StringVar(&check, "check", "", "")
	flag.Parse()

	if name == "" || path == "" {
		log.Fatal("name and path must be specified")
	}

	if check != "" {
		path = filepath.Join(path, name+"_"+check)
	} else {
		path = filepath.Join(path, name)
	}
	if err := os.MkdirAll(path, 0755); err != nil {
		log.Fatalf("failed to create path %q: %s", path, err.Error())
	}

	tmpl, err := template.New(name).Parse(tTmpl)
	if err != nil {
		log.Fatalf("failed to parse template: %s", err.Error())
	}

	filePath := filepath.Join(path, name+".go")
	f, err := os.Create(filePath)
	if err := os.MkdirAll(path, 0600); err != nil {
		log.Fatalf("failed to create file %q: %s", filePath, err.Error())
	}

	data := struct {
		Name  string
		UName string
		Check string
	}{
		name, strings.ToUpper(name), check,
	}
	if err := tmpl.Execute(f, &data); err != nil {
		log.Fatalf("failed to execute template: %s", err.Error())
	}
}
